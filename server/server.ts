import express from "express";
import bodyParser from "body-parser";
import path from "path";
import shell from "shelljs";
import cors from "cors";
import multer from "multer";
import fs from "fs";

const app = express();
const PORT = 3001;

app.use(cors()); // Middleware to enable CORS
app.use(bodyParser.json()); // Middleware to parse JSON requests

// PDF Cracking
// Destination folder for the received PDF files
const storage = multer.diskStorage({
  destination: "/home/kali/Documents/pdf-cracker/PDFs",
  filename: (req, file, cb) => {
    cb(null, file.originalname);
  },
});
const upload = multer({ storage });

app.post("/upload-and-crack-pdf", upload.single("pdfFile"), (req, res) => {
  const pdfFilePath = req.file.path; // Path to the saved PDF file

  if (fs.existsSync(pdfFilePath)) {
    console.log("PDF Received");
    const output = shell.exec(
      `/home/kali/Documents/pdf-cracker/crack-PDF-passwd ${pdfFilePath}`
    );
    return res.send(output.stdout);
  }
});

app.post("/clear-john-cache", (req, res) => {
  const output = shell.exec(
    "/home/kali/Documents/pdf-cracker/clear-john-cache"
  );
  return res.send(output.stdout);
});

// Recon
app.post("/nmap-scan", (req, res) => {
  const { command } = req.body;

  if (!command) {
    return res.status(400).json({ error: "Command is required" });
  }

  // TODO: Sanitize command

  // console.log(command);
  const output = shell.exec(command);

  if (output.code !== 0) {
    return res
      .status(500)
      .json({ error: "Error executing command", output: output.stderr });
  }

  res.json({ output: output.stdout });
});

// SSH Brute Force
app.post("/ssh-brute-force", (req, res) => {
  const { ip, user, port, wordlist } = req.body;

  if (!ip) {
    return res.status(400).json({ error: "IP is required" });
  }

  if (!user) {
    return res.status(400).json({ error: "User is required" });
  }

  if (!port) {
    return res.status(400).json({ error: "Port is required" });
  }

  if (!wordlist) {
    return res.status(400).json({ error: "Wordlist is required" });
  }

  const output = shell.exec(
    `hydra -t 4 -l ${user} -P /home/kali/Documents/my-wordlists/${wordlist} ssh://${ip} -s ${port}`
  );

  if (output.code !== 0) {
    return res
      .status(500)
      .json({ error: "Error executing command", output: output.stderr });
  }

  res.json({ output: output.stdout });
});

app.get("/wordlists", (req, res) => {
  const wordlists = shell.ls("/home/kali/Documents/my-wordlists");
  res.json({ wordlists });
});

// Deauth Attack
app.get("/iwconfig", (req, res) => {
  const output = shell.exec("iwconfig", { silent: true });
  if (output.stderr) {
    return res.send(output.stderr);
  }
  return res.send(output.stdout);
});

const setMonitorMode = (iface: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    shell.exec(
      `airmon-ng start ${iface}`,
      { silent: true },
      (code, stdout, stderr) => {
        // TODO: Change else to if and resolve outsite if
        // TODO: Change else to if and resolve outsite if
        // TODO: Change else to if and resolve outsite if
        // TODO: Change else to if and resolve outsite if
        // TODO: Change else to if and resolve outsite if
        // TODO: Change else to if and resolve outsite if
        if (code !== 0) {
          console.error(`exec error: ${stderr}`);
          reject(`Error setting ${iface} to monitor mode: ${stderr}`);
        } else {
          resolve(`Setting ${iface} to monitor mode... Done\n${stdout}`);
        }
      }
    );
  });
};

const listTargets = (ifacemon: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    shell.exec(
      `airodump-ng ${ifacemon}`,
      { silent: true },
      (code, stdout, stderr) => {
        if (code !== 0) {
          console.error(`exec error: ${stderr}`);
          reject(`Error listing targets: ${stderr}`);
        } else {
          resolve(`Listing all available targets:\n${stdout}`);
        }
      }
    );
  });
};

app.post("/selected-interface", async (req, res) => {
  const iface = req.body.iface;
  const ifacemon = `${iface}mon`;

  try {
    const monitorModeOutput = await setMonitorMode(iface);
    const targetsOutput = await listTargets(ifacemon);
    res.send(`${monitorModeOutput}\n${targetsOutput}`);
  } catch (error) {
    res.status(500).send(error);
  }
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
