import { runCommand } from "./sudoRunCommand";

export class InterfaceState {
  private mode: "managed" | "monitor" = "managed";
  private iface: string = process.env.INTERFACE;
  private channel: number | null = null;

  getInterface() { return this.mode === "monitor" ? `${this.iface}mon` : this.iface; }
  getMode() { return this.mode; }
  getChannel() { return this.channel; }

  async setMode(mode: "managed" | "monitor", channel?: number) {
    // If the interface is already in the desired mode, return
    if (mode === this.mode && channel === this.channel) {
      return;
    }

    // If channel is provided, set the interface to monitor mode on the specified channel
    if (typeof channel !== "undefined") {
      console.log(`AAAAAAAAAAAA; ${mode} ${channel} ${typeof channel}`);
      if (mode === "monitor") {
        await runCommand(`airmon-ng stop ${this.iface}mon`);
      }

      await runCommand("airmon-ng check kill");
      await runCommand(`airmon-ng start ${this.iface} ${channel}`);
      console.log(`Interface set to ${mode} mode on ch ${channel}`)

      this.channel = channel;
      this.mode = mode;
      return;
    }

    // Else, toggle the interface between monitor and managed mode
    if (mode === "monitor") {
      await runCommand("airmon-ng check kill");
      await runCommand(`airmon-ng start ${this.iface}`);
    } else {
      await runCommand(`airmon-ng stop ${this.iface}mon`);
    }

    this.mode = mode;
  }

  async initialize() {
    try {
      await runCommand(`airmon-ng stop ${this.iface}mon`);
      this.mode = "managed";
    } catch (error) {
      // wlan0mon does not exist, so the interface is already in managed mode
    }
  }
}

const interfaceState = new InterfaceState();

export default interfaceState;
